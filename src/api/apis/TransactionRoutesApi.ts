/* tslint:disable */
/* eslint-disable */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AnnounceTransactionInfoDTO,
    AnnounceTransactionInfoDTOFromJSON,
    AnnounceTransactionInfoDTOToJSON,
    Cosignature,
    CosignatureFromJSON,
    CosignatureToJSON,
    ModelError,
    ModelErrorFromJSON,
    ModelErrorToJSON,
    Order,
    OrderFromJSON,
    OrderToJSON,
    TransactionIds,
    TransactionIdsFromJSON,
    TransactionIdsToJSON,
    TransactionInfoDTO,
    TransactionInfoDTOFromJSON,
    TransactionInfoDTOToJSON,
    TransactionPage,
    TransactionPageFromJSON,
    TransactionPageToJSON,
    TransactionPayload,
    TransactionPayloadFromJSON,
    TransactionPayloadToJSON,
    TransactionTypeEnum,
    TransactionTypeEnumFromJSON,
    TransactionTypeEnumToJSON,
} from '../models';

export interface AnnounceCosignatureTransactionRequest {
    cosignature: Cosignature;
}

export interface AnnouncePartialTransactionRequest {
    transactionPayload: TransactionPayload;
}

export interface AnnounceTransactionRequest {
    transactionPayload: TransactionPayload;
}

export interface GetConfirmedTransactionRequest {
    transactionId: string;
}

export interface GetConfirmedTransactionsRequest {
    transactionIds: TransactionIds;
}

export interface GetPartialTransactionRequest {
    transactionId: string;
}

export interface GetPartialTransactionsRequest {
    transactionIds: TransactionIds;
}

export interface GetUnconfirmedTransactionRequest {
    transactionId: string;
}

export interface GetUnconfirmedTransactionsRequest {
    transactionIds: TransactionIds;
}

export interface SearchConfirmedTransactionsRequest {
    address?: string;
    recipientAddress?: string;
    signerPublicKey?: string;
    height?: string;
    fromHeight?: string;
    toHeight?: string;
    fromTransferAmount?: string;
    toTransferAmount?: string;
    type?: Array<TransactionTypeEnum>;
    embedded?: boolean;
    transferMosaicId?: string;
    pageSize?: number;
    pageNumber?: number;
    offset?: string;
    order?: Order;
}

export interface SearchPartialTransactionsRequest {
    address?: string;
    recipientAddress?: string;
    signerPublicKey?: string;
    height?: string;
    fromHeight?: string;
    toHeight?: string;
    fromTransferAmount?: string;
    toTransferAmount?: string;
    type?: Array<TransactionTypeEnum>;
    embedded?: boolean;
    transferMosaicId?: string;
    pageSize?: number;
    pageNumber?: number;
    offset?: string;
    order?: Order;
}

export interface SearchUnconfirmedTransactionsRequest {
    address?: string;
    recipientAddress?: string;
    signerPublicKey?: string;
    height?: string;
    fromHeight?: string;
    toHeight?: string;
    fromTransferAmount?: string;
    toTransferAmount?: string;
    type?: Array<TransactionTypeEnum>;
    embedded?: boolean;
    transferMosaicId?: string;
    pageSize?: number;
    pageNumber?: number;
    offset?: string;
    order?: Order;
}

/**
 * 
 */
export class TransactionRoutesApi extends runtime.BaseAPI {

    /**
     * Announces a cosignature transaction to the network.
     * Announce a cosignature transaction
     */
    async announceCosignatureTransactionRaw(requestParameters: AnnounceCosignatureTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<AnnounceTransactionInfoDTO>> {
        if (requestParameters.cosignature === null || requestParameters.cosignature === undefined) {
            throw new runtime.RequiredError('cosignature','Required parameter requestParameters.cosignature was null or undefined when calling announceCosignatureTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/transactions/cosignature`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CosignatureToJSON(requestParameters.cosignature),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnounceTransactionInfoDTOFromJSON(jsonValue));
    }

    /**
     * Announces a cosignature transaction to the network.
     * Announce a cosignature transaction
     */
    async announceCosignatureTransaction(requestParameters: AnnounceCosignatureTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<AnnounceTransactionInfoDTO> {
        const response = await this.announceCosignatureTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Announces an aggregate bonded transaction to the network.
     * Announce an aggregate bonded transaction
     */
    async announcePartialTransactionRaw(requestParameters: AnnouncePartialTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<AnnounceTransactionInfoDTO>> {
        if (requestParameters.transactionPayload === null || requestParameters.transactionPayload === undefined) {
            throw new runtime.RequiredError('transactionPayload','Required parameter requestParameters.transactionPayload was null or undefined when calling announcePartialTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/transactions/partial`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionPayloadToJSON(requestParameters.transactionPayload),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnounceTransactionInfoDTOFromJSON(jsonValue));
    }

    /**
     * Announces an aggregate bonded transaction to the network.
     * Announce an aggregate bonded transaction
     */
    async announcePartialTransaction(requestParameters: AnnouncePartialTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<AnnounceTransactionInfoDTO> {
        const response = await this.announcePartialTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
     * Announce a new transaction
     */
    async announceTransactionRaw(requestParameters: AnnounceTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<AnnounceTransactionInfoDTO>> {
        if (requestParameters.transactionPayload === null || requestParameters.transactionPayload === undefined) {
            throw new runtime.RequiredError('transactionPayload','Required parameter requestParameters.transactionPayload was null or undefined when calling announceTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/transactions`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionPayloadToJSON(requestParameters.transactionPayload),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AnnounceTransactionInfoDTOFromJSON(jsonValue));
    }

    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions. 
     * Announce a new transaction
     */
    async announceTransaction(requestParameters: AnnounceTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<AnnounceTransactionInfoDTO> {
        const response = await this.announceTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * Get confirmed transaction information
     */
    async getConfirmedTransactionRaw(requestParameters: GetConfirmedTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TransactionInfoDTO>> {
        if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
            throw new runtime.RequiredError('transactionId','Required parameter requestParameters.transactionId was null or undefined when calling getConfirmedTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/transactions/confirmed/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionInfoDTOFromJSON(jsonValue));
    }

    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * Get confirmed transaction information
     */
    async getConfirmedTransaction(requestParameters: GetConfirmedTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TransactionInfoDTO> {
        const response = await this.getConfirmedTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * Get confirmed trasactions information
     */
    async getConfirmedTransactionsRaw(requestParameters: GetConfirmedTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<TransactionInfoDTO>>> {
        if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
            throw new runtime.RequiredError('transactionIds','Required parameter requestParameters.transactionIds was null or undefined when calling getConfirmedTransactions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/transactions/confirmed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionIdsToJSON(requestParameters.transactionIds),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionInfoDTOFromJSON));
    }

    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * Get confirmed trasactions information
     */
    async getConfirmedTransactions(requestParameters: GetConfirmedTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<TransactionInfoDTO>> {
        const response = await this.getConfirmedTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns partial transaction information given a transactionId or hash.
     * Get partial transaction information
     */
    async getPartialTransactionRaw(requestParameters: GetPartialTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TransactionInfoDTO>> {
        if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
            throw new runtime.RequiredError('transactionId','Required parameter requestParameters.transactionId was null or undefined when calling getPartialTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/transactions/partial/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionInfoDTOFromJSON(jsonValue));
    }

    /**
     * Returns partial transaction information given a transactionId or hash.
     * Get partial transaction information
     */
    async getPartialTransaction(requestParameters: GetPartialTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TransactionInfoDTO> {
        const response = await this.getPartialTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns partial transactions information for a given array of transactionIds.
     * Get partial trasactions information
     */
    async getPartialTransactionsRaw(requestParameters: GetPartialTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<TransactionInfoDTO>>> {
        if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
            throw new runtime.RequiredError('transactionIds','Required parameter requestParameters.transactionIds was null or undefined when calling getPartialTransactions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/transactions/partial`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionIdsToJSON(requestParameters.transactionIds),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionInfoDTOFromJSON));
    }

    /**
     * Returns partial transactions information for a given array of transactionIds.
     * Get partial trasactions information
     */
    async getPartialTransactions(requestParameters: GetPartialTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<TransactionInfoDTO>> {
        const response = await this.getPartialTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * Get unconfirmed transaction information
     */
    async getUnconfirmedTransactionRaw(requestParameters: GetUnconfirmedTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TransactionInfoDTO>> {
        if (requestParameters.transactionId === null || requestParameters.transactionId === undefined) {
            throw new runtime.RequiredError('transactionId','Required parameter requestParameters.transactionId was null or undefined when calling getUnconfirmedTransaction.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/transactions/unconfirmed/{transactionId}`.replace(`{${"transactionId"}}`, encodeURIComponent(String(requestParameters.transactionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionInfoDTOFromJSON(jsonValue));
    }

    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * Get unconfirmed transaction information
     */
    async getUnconfirmedTransaction(requestParameters: GetUnconfirmedTransactionRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TransactionInfoDTO> {
        const response = await this.getUnconfirmedTransactionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * Get unconfirmed trasactions information
     */
    async getUnconfirmedTransactionsRaw(requestParameters: GetUnconfirmedTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<Array<TransactionInfoDTO>>> {
        if (requestParameters.transactionIds === null || requestParameters.transactionIds === undefined) {
            throw new runtime.RequiredError('transactionIds','Required parameter requestParameters.transactionIds was null or undefined when calling getUnconfirmedTransactions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/transactions/unconfirmed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TransactionIdsToJSON(requestParameters.transactionIds),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionInfoDTOFromJSON));
    }

    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * Get unconfirmed trasactions information
     */
    async getUnconfirmedTransactions(requestParameters: GetUnconfirmedTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<Array<TransactionInfoDTO>> {
        const response = await this.getUnconfirmedTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
     * Search confirmed transactions
     */
    async searchConfirmedTransactionsRaw(requestParameters: SearchConfirmedTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TransactionPage>> {
        const queryParameters: any = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.recipientAddress !== undefined) {
            queryParameters['recipientAddress'] = requestParameters.recipientAddress;
        }

        if (requestParameters.signerPublicKey !== undefined) {
            queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
        }

        if (requestParameters.height !== undefined) {
            queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.fromHeight !== undefined) {
            queryParameters['fromHeight'] = requestParameters.fromHeight;
        }

        if (requestParameters.toHeight !== undefined) {
            queryParameters['toHeight'] = requestParameters.toHeight;
        }

        if (requestParameters.fromTransferAmount !== undefined) {
            queryParameters['fromTransferAmount'] = requestParameters.fromTransferAmount;
        }

        if (requestParameters.toTransferAmount !== undefined) {
            queryParameters['toTransferAmount'] = requestParameters.toTransferAmount;
        }

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.embedded !== undefined) {
            queryParameters['embedded'] = requestParameters.embedded;
        }

        if (requestParameters.transferMosaicId !== undefined) {
            queryParameters['transferMosaicId'] = requestParameters.transferMosaicId;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['pageNumber'] = requestParameters.pageNumber;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/transactions/confirmed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionPageFromJSON(jsonValue));
    }

    /**
     * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time. 
     * Search confirmed transactions
     */
    async searchConfirmedTransactions(requestParameters: SearchConfirmedTransactionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TransactionPage> {
        const response = await this.searchConfirmedTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of partial transactions.
     * Search partial transactions
     */
    async searchPartialTransactionsRaw(requestParameters: SearchPartialTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TransactionPage>> {
        const queryParameters: any = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.recipientAddress !== undefined) {
            queryParameters['recipientAddress'] = requestParameters.recipientAddress;
        }

        if (requestParameters.signerPublicKey !== undefined) {
            queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
        }

        if (requestParameters.height !== undefined) {
            queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.fromHeight !== undefined) {
            queryParameters['fromHeight'] = requestParameters.fromHeight;
        }

        if (requestParameters.toHeight !== undefined) {
            queryParameters['toHeight'] = requestParameters.toHeight;
        }

        if (requestParameters.fromTransferAmount !== undefined) {
            queryParameters['fromTransferAmount'] = requestParameters.fromTransferAmount;
        }

        if (requestParameters.toTransferAmount !== undefined) {
            queryParameters['toTransferAmount'] = requestParameters.toTransferAmount;
        }

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.embedded !== undefined) {
            queryParameters['embedded'] = requestParameters.embedded;
        }

        if (requestParameters.transferMosaicId !== undefined) {
            queryParameters['transferMosaicId'] = requestParameters.transferMosaicId;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['pageNumber'] = requestParameters.pageNumber;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/transactions/partial`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionPageFromJSON(jsonValue));
    }

    /**
     * Returns an array of partial transactions.
     * Search partial transactions
     */
    async searchPartialTransactions(requestParameters: SearchPartialTransactionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TransactionPage> {
        const response = await this.searchPartialTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns an array of unconfirmed transactions.
     * Search unconfirmed transactions
     */
    async searchUnconfirmedTransactionsRaw(requestParameters: SearchUnconfirmedTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<runtime.ApiResponse<TransactionPage>> {
        const queryParameters: any = {};

        if (requestParameters.address !== undefined) {
            queryParameters['address'] = requestParameters.address;
        }

        if (requestParameters.recipientAddress !== undefined) {
            queryParameters['recipientAddress'] = requestParameters.recipientAddress;
        }

        if (requestParameters.signerPublicKey !== undefined) {
            queryParameters['signerPublicKey'] = requestParameters.signerPublicKey;
        }

        if (requestParameters.height !== undefined) {
            queryParameters['height'] = requestParameters.height;
        }

        if (requestParameters.fromHeight !== undefined) {
            queryParameters['fromHeight'] = requestParameters.fromHeight;
        }

        if (requestParameters.toHeight !== undefined) {
            queryParameters['toHeight'] = requestParameters.toHeight;
        }

        if (requestParameters.fromTransferAmount !== undefined) {
            queryParameters['fromTransferAmount'] = requestParameters.fromTransferAmount;
        }

        if (requestParameters.toTransferAmount !== undefined) {
            queryParameters['toTransferAmount'] = requestParameters.toTransferAmount;
        }

        if (requestParameters.type) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.embedded !== undefined) {
            queryParameters['embedded'] = requestParameters.embedded;
        }

        if (requestParameters.transferMosaicId !== undefined) {
            queryParameters['transferMosaicId'] = requestParameters.transferMosaicId;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.pageNumber !== undefined) {
            queryParameters['pageNumber'] = requestParameters.pageNumber;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.order !== undefined) {
            queryParameters['order'] = requestParameters.order;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/transactions/unconfirmed`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionPageFromJSON(jsonValue));
    }

    /**
     * Returns an array of unconfirmed transactions.
     * Search unconfirmed transactions
     */
    async searchUnconfirmedTransactions(requestParameters: SearchUnconfirmedTransactionsRequest = {}, initOverrides?: RequestInit | runtime.InitOverideFunction): Promise<TransactionPage> {
        const response = await this.searchUnconfirmedTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
